import numpy as np
import pandas as pd
from typing import List, Dict, Tuple
from dataclasses import dataclass
import re
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import warnings
warnings.filterwarnings('ignore')

@dataclass
class Video:
    """Блокнотик атрибутов видео"""
    id: str
    title: str
    description: str
    tags: List[str]
    category: str
    duration: int  # в секундах
    upload_date: str
    views: int
    likes: int
    creator: str
    embedding: np.array = None

class LLMVideoRecommender:
    """
    Система рекомендации видео на основе LLM
    Использует текстовый анализ и семантическое понимание для рекомендации видео
    """

    def __init__(self):
        """
        Инициализация системы рекомендаций
        """
        self.videos: List[Video] = []
        self.user_profiles: Dict[str, Dict] = {}
        self.video_embeddings = None
        self.tfidf_vectorizer = TfidfVectorizer(max_features=5000, stop_words='english')
        self.use_tfidf = True

    def add_video(self, video: Video):
        """Добавление видео в систему рекомендаций"""
        self.videos.append(video)

    def add_videos(self, videos: List[Video]):
        """Добавление несколько видео в систему рекомендаций"""
        self.videos.extend(videos)

    def generate_embeddings(self):
        """Генерация тегов для всех видео с использованием TF-IDF"""
        # Использование TF-IDF для текстовых функций
        if not self.videos:
            # Пустой список
            self.video_embeddings = None
            return

        all_texts = [f"{v.title} {v.description} {' '.join(v.tags)} {v.category}" for v in self.videos]
        self.video_embeddings = self.tfidf_vectorizer.fit_transform(all_texts)

    def create_user_profile(self, user_id: str, preferences: Dict):
        """
        Создание или обновление пользовательского профиля(тегов)
        :param user_id: айди пользователя
        :param preferences: Массив, содержащий пользовательские предпочтения
        """
        self.user_profiles[user_id] = {
            'preferences': preferences,
            'watch_history': [],
            'liked_videos': [],
            'disliked_videos': []
        }

    def update_user_watch_history(self, user_id: str, video_id: str, rating: float = None):
        """Обновление истории просмотров пользователя"""
        if user_id not in self.user_profiles:
            self.create_user_profile(user_id, {})

        self.user_profiles[user_id]['watch_history'].append({
            'video_id': video_id,
            'timestamp': pd.Timestamp.now(),
            'rating': rating
        })

    def get_video_by_id(self, video_id: str) -> Video:
        """Получение видео по его ID"""
        for video in self.videos:
            if video.id == video_id:
                return video
        return None

    def generate_user_embedding(self, user_id: str) -> np.array:
        """Генерация тегов пользователя на основе его предпочтений и истории"""
        if self.video_embeddings is None:
            # Если нет видео
            return np.array([])

        if user_id not in self.user_profiles:
            # если несуществующий профиль
            return np.zeros(self.video_embeddings.shape[1])

        user_profile = self.user_profiles[user_id]
        profile_texts = []

        # Добавление предпочтений
        if 'preferences' in user_profile and user_profile['preferences']:
            prefs = user_profile['preferences']
            pref_text = " ".join([
                f"{k} {v}" for k, v in prefs.items()
                if isinstance(v, str) or isinstance(v, list) and len(v) > 0
            ])
            profile_texts.append(pref_text)

        # Описание понравившихся видео
        for video_id in user_profile.get('liked_videos', []):
            video = self.get_video_by_id(video_id)
            if video:
                profile_texts.append(f"{video.title} {video.description}")

        # На основе истории просмотра
        for item in user_profile.get('watch_history', []):
            video = self.get_video_by_id(item['video_id'])
            if video:
                profile_texts.append(f"{video.title} {video.description}")

        if not profile_texts:
            # Если нет в тегах профиля
            return np.zeros(self.video_embeddings.shape[1])

        # Совмещение текста всех параметров
        combined_text = " ".join(profile_texts)

        # TF-IDF векторизация
        try:
            return self.tfidf_vectorizer.transform([combined_text]).toarray()[0]
        except ValueError:
            # Если текст содержит лишние теги
            return np.zeros(self.video_embeddings.shape[1])

    def calculate_similarity(self, user_embedding: np.array, video_idx: int) -> float:
        """Расчет сходства между тегами пользователя и видео с использованием косинусного сходства"""
        if self.video_embeddings is None:
            return 0.0

        user_vec = user_embedding.reshape(1, -1)
        video_vec = self.video_embeddings[video_idx].reshape(1, -1)
        return cosine_similarity(user_vec, video_vec)[0][0]

    def get_recommendations(self, user_id: str, n_recommendations: int = 10,
                           exclude_watched: bool = True) -> List[Tuple[Video, float]]:
        """
        Получение рекомендаций видео для пользователя
        :param user_id: Идентификатор пользователя
        :param n_recommendations: Количество рекомендаций для выдачи
        :param exclude_watched: Исключать ли видео из истории просмотров
        :return: Список кортежей (Видео, оценка_сходства)
        """
        if self.video_embeddings is None:
            # Если нет тегов видео
            return []

        user_embedding = self.generate_user_embedding(user_id)

        # Проверка тегов рекомендаций пользователя
        if user_embedding.size == 0:
            return []

        # Поиск повторений(просмотренных видео)
        similarities = []
        for i, video in enumerate(self.videos):
            if exclude_watched and user_id in self.user_profiles:
                watched_ids = [item['video_id'] for item in self.user_profiles[user_id].get('watch_history', [])]
                if video.id in watched_ids:
                    continue

            similarity = self.calculate_similarity(user_embedding, i)
            similarities.append((video, similarity))

        # Сортировка по убыванию сходства
        similarities.sort(key=lambda x: x[1], reverse=True)

        # Выдача N наиболее подходящих рекомендаций
        return similarities[:n_recommendations]

    def get_content_based_recommendations(self, video_id: str, n_recommendations: int = 10) -> List[Tuple[Video, float]]:
        """
        Получение контентных рекомендаций, похожих на заданное видео
        :param video_id: ID видео-референса
        :param n_recommendations: Количество рекомендаций для возврата
        :return: Список кортежей (Видео, оценка_сходства)
        """
        if self.video_embeddings is None:
            # Если нет тегов видео
            return []

        # Поиск видео-референса
        ref_video = None
        ref_idx = -1
        for i, video in enumerate(self.videos):
            if video.id == video_id:
                ref_video = video
                ref_idx = i
                break

        if ref_video is None:
            return []

        # Поиск сходств с видео-референсом
        similarities = []
        ref_embedding = self.video_embeddings[ref_idx].toarray().flatten()  # Конвертация нулевых значений в ненулевые

        for i, video in enumerate(self.videos):
            if video.id == video_id:  # Пропуск видео, взятого за референс
                continue

            similarity = self.calculate_similarity(ref_embedding, i)
            similarities.append((video, similarity))

        # Сортировка по убыванию сходства
        similarities.sort(key=lambda x: x[1], reverse=True)

        # Выдача N наиболее подходящих рекомендаций
        return similarities[:n_recommendations]

    def get_hybrid_recommendations(self, user_id: str, n_recommendations: int = 10,
                                 content_weight: float = 0.3) -> List[Tuple[Video, float]]:
        """
        Получение гибридных рекомендаций, объединяющих коллаборативную и контентную фильтрацию
        :param user_id: Идентификатор пользователя
        :param n_recommendations: Количество рекомендаций для возврата
        :param content_weight: Вес для оценки контента (1-content_weight - для пользовательских предпочтений)
        :return: Список кортежей (Видео, объединенная_оценка)
        """
        user_embedding = self.generate_user_embedding(user_id)

        # Получение оценки предпочтений пользователя
        user_scores = []
        for i in range(len(self.videos)):
            similarity = self.calculate_similarity(user_embedding, i)
            user_scores.append(similarity)

        # Приведение оценки в нормальный вид
        user_scores = np.array(user_scores)
        if np.max(user_scores) > 0:
            user_scores = user_scores / np.max(user_scores)

        # Подсчет комбинированной оценки
        combined_scores = []
        for i, video in enumerate(self.videos):
            user_pref_score = user_scores[i]

            # Учитываем лайкнутые видео
            content_score = 0
            if user_id in self.user_profiles:
                liked_videos = self.user_profiles[user_id].get('liked_videos', [])
                if liked_videos:
                    max_content_sim = 0
                    for liked_video_id in liked_videos[-5:]:  # Учитываем последние 5 лайкнутых видео
                        liked_video = self.get_video_by_id(liked_video_id)
                        if liked_video:
                            # Находим индекс лайкнутых видео
                            for j, v in enumerate(self.videos):
                                if v.id == liked_video_id:
                                    liked_embedding = self.video_embeddings[j].toarray().flatten()  # Конвертация из нулевых в ненулевые
                                    sim = self.calculate_similarity(liked_embedding, i)
                                    max_content_sim = max(max_content_sim, sim)
                                    break
                    content_score = max_content_sim

            combined_score = (1 - content_weight) * user_pref_score + content_weight * content_score
            combined_scores.append((video, combined_score))

        # Сортируем комбинированную оценку по убыванию
        combined_scores.sort(key=lambda x: x[1], reverse=True)

        # Выдача N наиболее подходящих рекомендаций
        return combined_scores[:n_recommendations]

def create_sample_data() -> List[Video]:
    """Создание образцов данных видео для тестирования"""
    sample_videos = [
        Video(
            id="vid1",
            title="Python Machine Learning Tutorial",
            description="Learn machine learning with Python from scratch",
            tags=["python", "machine learning", "tutorial", "programming"],
            category="Education",
            duration=1800,
            upload_date="2023-01-15",
            views=150000,
            likes=5000,
            creator="ML Academy"
        ),
        Video(
            id="vid2",
            title="Advanced React Patterns",
            description="Explore advanced React patterns and best practices",
            tags=["react", "javascript", "web development", "frontend"],
            category="Technology",
            duration=2400,
            upload_date="2023-02-20",
            views=95000,
            likes=3200,
            creator="React Masters"
        ),
        Video(
            id="vid3",
            title="Cooking Italian Pasta",
            description="Learn to cook authentic Italian pasta at home",
            tags=["cooking", "italian", "pasta", "food"],
            category="Food",
            duration=900,
            upload_date="2023-03-10",
            views=210000,
            likes=8500,
            creator="Chef Mario"
        ),
        Video(
            id="vid4",
            title="Travel to Japan Guide",
            description="Complete guide to traveling in Japan",
            tags=["travel", "japan", "tourism", "adventure"],
            category="Travel",
            duration=3000,
            upload_date="2023-01-30",
            views=320000,
            likes=12000,
            creator="Wanderlust World"
        ),
        Video(
            id="vid5",
            title="Financial Planning Basics",
            description="Essential financial planning strategies for beginners",
            tags=["finance", "investment", "money", "planning"],
            category="Finance",
            duration=1500,
            upload_date="2023-02-05",
            views=78000,
            likes=2800,
            creator="Money Matters"
        ),
        Video(
            id="vid6",
            title="Deep Learning with PyTorch",
            description="Comprehensive PyTorch deep learning tutorial",
            tags=["pytorch", "deep learning", "neural networks", "ai"],
            category="Education",
            duration=3600,
            upload_date="2023-03-01",
            views=180000,
            likes=7500,
            creator="AI University"
        ),
        Video(
            id="vid7",
            title="JavaScript ES6 Features",
            description="Learn modern JavaScript ES6+ features",
            tags=["javascript", "es6", "programming", "web development"],
            category="Technology",
            duration=1200,
            upload_date="2023-01-20",
            views=110000,
            likes=4200,
            creator="Code Masters"
        ),
        Video(
            id="vid8",
            title="Healthy Meal Prep Ideas",
            description="Easy and healthy meal prep ideas for busy people",
            tags=["health", "cooking", "meal prep", "nutrition"],
            category="Food",
            duration=1000,
            upload_date="2023-02-15",
            views=145000,
            likes=6800,
            creator="Health & Food"
        )
    ]
    return sample_videos

def main():
    """Основная функция для демонстрации работы системы рекомендаций"""
    print("Инициализация системы рекомендаций...")

    # Создание функции рекомендаций
    recommender = LLMVideoRecommender()

    # Добавление видео
    sample_videos = create_sample_data()
    recommender.add_videos(sample_videos)

    # Генерация эмбдедов для всех видео
    print("Генерация тегов видео...")
    recommender.generate_embeddings()

    # Создание профиля пользователя
    user_preferences = {
        "interests": ["python", "machine learning", "programming"],
        "preferred_categories": ["Education", "Technology"],
        "min_duration": 1000,
        "max_duration": 3000
    }

    recommender.create_user_profile("user123", user_preferences)

    # Добавление истории просмотров
    recommender.update_user_watch_history("user123", "vid1", rating=5.0)
    recommender.update_user_watch_history("user123", "vid6", rating=4.5)

    # Добавление лайкнутых видео
    recommender.user_profiles["user123"]["liked_videos"] = ["vid1", "vid6"]

    print("\nПолучение персонализированных рекомендаций для user123...")
    recommendations = recommender.get_recommendations("user123", n_recommendations=5)

    print("\nТоп 5 Рекомендаций:")
    for i, (video, score) in enumerate(recommendations, 1):
        print(f"{i}. {video.title} (Score: {score:.3f})")
        print(f"   Категория: {video.category}, Просмотры: {video.views:,}")
        print(f"   Теги: {', '.join(video.tags[:3])}")
        print()

    print("\nПолучение рекомендаций контента, похожего на 'Python Machine Learning Tutorial'...")
    content_recs = recommender.get_content_based_recommendations("vid1", n_recommendations=3)

    print("\nРекомендации, основанные на контенте:")
    for i, (video, score) in enumerate(content_recs, 1):
        print(f"{i}. {video.title} (Score: {score:.3f})")
        print(f"   Категория: {video.category}, Просмотры: {video.views:,}")
        print()

    print("\nПолучение гибридных рекомендаций...")
    hybrid_recs = recommender.get_hybrid_recommendations("user123", n_recommendations=3)

    print("\nГибридные рекомендации:")
    for i, (video, score) in enumerate(hybrid_recs, 1):
        print(f"{i}. {video.title} (Score: {score:.3f})")
        print(f"   Категория: {video.category}, Просмотры: {video.views:,}")
        print()

if __name__ == "__main__":
    main()
